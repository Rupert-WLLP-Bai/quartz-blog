---
title: 6.24-联洲-嵌入式-提前批-二面
date: 2025-06-26T15:55:07.000Z
tags: [Recruitment, Embedded, Interview]
---

# 6.24 联洲 嵌入式 提前批 二面
(Momenta 实习经历 & 基础知识考察)

1. **自我介绍**
   - 回答：学历，实习，常用语言

2. **Momenta 实习三个项目讲一下**
   - 回答：简单说了一下产出

3. **Arxml 生成脚本是怎么设计的**
   - 回答：
     - 数据类型复杂，结构嵌套，内存对齐（字段的顺序不能变）
     - AUTOSAR定义的标签很多，树形结构抽象出来放在不同文件，序列化单独实现，Optional
     - 触发方式多（周期性，数据到达触发，服务调用触发，初始化触发），代码复杂分支结构用策略模式替代
     - CI/CD自动化集成与校验，提示接口变更与错误

4. **假设嵌入式方面有类似的工作，设计上需要注意什么**
   - 回答：版本管理，理解需求，实现最小原型，留出后续扩展空间（这个回答好像不是很满意）

5. **嵌入式场景，不同固件版本和配置，一般怎么处理**
   - 回答：HSM逆版本刷新固件锁死，防止安全降级攻击，测试的时候关闭Anti-Rollback（感觉回答偏了）

6. **举个具体的例子，假设我有ABC三个板子，配置文件的版本分别是123，我如果想用C的配置在旧的固件版本上运行，在设计上需要注意什么**
   - 回答：配置与代码解耦，兼容性方面问题加上错误处理与异常抛出，保证程序不panic（这个应该回答HAL方面的，定义硬件抽象API，封装对GPIO、UART、SPI等的操作接口，具体芯片的底层实现切换即可）

7. **数据结构、计组、操作系统都学过吧，问一些基础问题，首先常用的数据结构**
   - 回答：链表，队列，栈，哈希表，树，图，并查集，字典树，位图

8. **Linux的中断讲一下**
   - 回答：中断用于异步通知CPU事件需要处理，避免轮询，分为硬中断和软中断（这里应该还有异常，除零错误，缺页异常），硬中断是外设发信号给CPU，软中断延迟处理。然后说了一下系统调用，syscall，通过中断向量表找到系统调用处理函数 （这里回答得不够全，Linux中断的具体实现忘了）

9. **内存泄漏的问题怎么排查**
   - 回答：使用valgrind memcheck，主要有Definitely lost，Indirectly lost，Possibly lost

10. **不使用工具怎么排查**
    - 回答：直接对malloc，free进行插桩，或者对mmap和brk写一个动态库hook？或者用backtrace？（这里不是很确定想问什么）

11. **嵌入式环境中还用valgrind吗**
    - 回答：可以使用htop，ps观察程序内存是否持续增长（好像不是很满意，但确实不能用，因为占用太高了）

12. **Makefile 中的 configure.ac 是什么**
    - 回答：生成对应平台的Makefile，自己很少写，一般用cmake或者bazel

13. **硕士毕业设计做的什么**
    - 回答：推荐系统相关，点击率预测，语义解耦

14. **为什么没写奖学金**
    - 回答：太菜了没有

15. **（智力题）140g的盐，有2g和7g的砝码，天平，最少几次分出50g和90g**
    - 回答：已经宕机了，回答是从9开始*2，相当于90=9*10，用1,2,4可以组合出2+4+4=10，所以是4次
    - 回复：为什么不考虑第一次平分？第一次70*2，第二次再平分35*2，第三次用7-2分出15,20，得到70+20

16. **coding，一个数组，大于等于limit的放右边降序，剩下的放左边（不用有序）**
    - 回答：最多应该就做到原地+o(nlogn)
    - 首先双指针swap，再std::sort(arr.begin() + i, arr.end(), std::greater<int>());

17. **反问**

## 答案整理：Linux中断
**外设触发IRQ信号 → CPU检测到中断 → 保存上下文 → 根据IDT跳转ISR入口 → 调用ISR → ISR处理硬件状态 → 清除中断标志 → 调度软中断/Tasklet → 恢复上下文 → 返回用户程序**

1. **中断向量表（IDT）**
   - Linux 内核启动时，会建立中断描述符表（IDT），每个条目对应一个中断向量号和处理函数地址。
   - 硬件中断到来时，通过 IDT 跳转执行对应的中断处理函数。

2. **中断处理程序注册**
   - 驱动模块通过 request_irq() 注册中断处理函数，内核把处理函数与 IRQ 号关联。
   - 内核维护 irq_desc 结构体，保存每个 IRQ 的状态和处理函数链表。

3. **顶半部（Top Half）——中断服务例程（ISR）**
   - ISR 是快速响应中断的函数，读取设备状态、清除中断标志。
   - ISR 运行在中断上下文，不允许睡眠。
   - ISR 不能执行耗时任务，尽快返回。

4. **底半部（Bottom Half）——软中断、Tasklet 和工作队列**
   - 为避免 ISR 过长，耗时任务推迟到底半部处理。
   - Linux 提供多种底半部机制：
     - SoftIRQ：软中断，上下文不可睡眠
     - Tasklet：基于软中断的轻量级机制，保证执行顺序
     - Workqueue：可睡眠，可以调度到用户态进程上下文

5. **中断屏蔽和嵌套**
   - Linux 内核自动屏蔽当前 CPU 的中断，避免中断嵌套。
   - 支持本地和全局中断屏蔽，确保临界区安全。
