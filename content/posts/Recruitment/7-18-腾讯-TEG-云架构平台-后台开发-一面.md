---
title: 7-18-è…¾è®¯-TEG-äº‘æ¶æ„å¹³å°-åå°å¼€å‘-ä¸€é¢
date: 2025-07-18T12:55:32.000Z
tags: [ç§‹æ‹›, è…¾è®¯, åç«¯, ç½‘ç»œ, TEG, äº‘æ¶æ„å¹³å°]
---

## ç®—æ³•é¢˜

å®ç°ä¸€ä¸ªç®€å•çš„æ–‡ä»¶ç³»ç»Ÿï¼Œæ”¯æŒ `mkdir`ã€`mkfile`ã€`ls`ã€`tree` ç­‰æ“ä½œã€‚

```cpp
#include <iostream>
#include <unordered_map>
#include <memory>
#include <sstream>
#include <vector>
#include <algorithm>
using namespace std;

class FSNode {
public:
    string name;
    FSNode(const string& name) : name(name) {}
    virtual bool is_file() const = 0;
    virtual ~FSNode() = default;
};

class File : public FSNode {
public:
    string content;
    File(const string& name) : FSNode(name) {}
    bool is_file() const override { return true; }
};

class Dir : public FSNode {
public:
    unordered_map<string, unique_ptr<FSNode>> children;
    Dir(const string& name) : FSNode(name) {}
    bool is_file() const override { return false; }
};

class FileSystem {
private:
    unique_ptr<Dir> root;

    vector<string> split(const string& path) {
        vector<string> parts;
        stringstream ss(path);
        string item;
        while (getline(ss, item, '/')) {
            if (!item.empty()) parts.push_back(item);
        }
        return parts;
    }

    Dir* traverse_dir(const vector<string>& parts, bool create = false) {
        Dir* curr = root.get();
        for (const string& part : parts) {
            if (!curr->children.count(part)) {
                if (create) {
                    curr->children[part] = make_unique<Dir>(part);
                } else {
                    return nullptr;
                }
            }
            FSNode* node = curr->children[part].get();
            if (node->is_file()) return nullptr;
            curr = static_cast<Dir*>(node);
        }
        return curr;
    }

    FSNode* get_node(const vector<string>& parts) {
        Dir* curr = root.get();
        for (size_t i = 0; i < parts.size(); ++i) {
            if (!curr->children.count(parts[i])) return nullptr;
            FSNode* node = curr->children[parts[i]].get();
            if (i == parts.size() - 1) return node;
            if (node->is_file()) return nullptr;
            curr = static_cast<Dir*>(node);
        }
        return curr;
    }

public:
    FileSystem() {
        root = make_unique<Dir>("/");
    }

    void mkdir(const string& path) {
        auto parts = split(path);
        Dir* curr = root.get();
        for (const string& part : parts) {
            if (!curr->children.count(part)) {
                curr->children[part] = make_unique<Dir>(part);
            } else if (curr->children[part]->is_file()) {
                cout << "mkdir: cannot create directory '" << path << "': Not a directory\n";
                return;
            }
            curr = static_cast<Dir*>(curr->children[part].get());
        }
    }

    void mkfile(const string& path) {
        auto parts = split(path);
        if (parts.empty()) return;
        string filename = parts.back();
        parts.pop_back();
        Dir* dir = traverse_dir(parts, false);
        if (!dir) {
            cout << "mkfile: cannot create file '" << path << "': No such directory\n";
            return;
        }
        if (dir->children.count(filename) && !dir->children[filename]->is_file()) {
            cout << "mkfile: cannot create file '" << path << "': Is a directory\n";
            return;
        }
        dir->children[filename] = make_unique<File>(filename);
    }

    void ls(const string& path) {
        auto parts = split(path);
        if (parts.empty()) {
            // root dir
            vector<string> res;
            for (auto& [k, _] : root->children) res.push_back(k);
            sort(res.begin(), res.end());
            for (auto& name : res) cout << name << " ";
            cout << endl;
            return;
        }

        FSNode* node = get_node(parts);
        if (!node) {
            cout << "ls: cannot access '" << path << "': No such file or directory\n";
            return;
        }

        if (node->is_file()) {
            cout << node->name << endl;
            return;
        }

        Dir* dir = static_cast<Dir*>(node);
        vector<string> res;
        for (auto& [k, _] : dir->children) res.push_back(k);
        sort(res.begin(), res.end());
        for (auto& name : res) cout << name << " ";
        cout << endl;
    }

    void tree(const string& path = "/") {
        auto parts = split(path);
        FSNode* node = root.get();

        if (!parts.empty()) {
            node = get_node(parts);
            if (!node) {
                cout << "tree: cannot access '" << path << "': No such file or directory\n";
                return;
            }
            if (node->is_file()) {
                cout << "- " << node->name << endl;
                return;
            }
        }

        print_tree(node, 0);
    }

    void print_tree(FSNode* node, int depth) {
        if (node != root.get()) {
            cout << string(depth * 2, ' ') << (node->is_file() ? "- " : "+ ") << node->name << endl;
        }
        if (!node->is_file()) {
            Dir* dir = static_cast<Dir*>(node);
            for (auto& [_, child] : dir->children) {
                print_tree(child.get(), depth + 1);
            }
        }
    }
};

int main() {
    FileSystem fs;
    fs.mkdir("/a/b/c");
    fs.mkfile("/a/b/c/file.txt");
    fs.ls("/a/b/c");
    fs.tree("/a");
    fs.tree();
    fs.ls("/a/b/d"); // should show error
    fs.mkfile("/a/b/d/file.txt"); // should show error
    return 0;
}
```

## ç®€ç­”é¢˜

---

### ç¬¬ä¸€é¢˜ï¼šç»“æ„ä½“å†…å­˜ä¸æŒ‡é’ˆåç§»

```cpp
struct T {
    unsigned char a;
    int b;
};

int q1() {
    T t;
    memset(&t, 0xff, sizeof(T));
    t.a = 0;
    t.b = 0;
    unsigned char* p = &t.a + 1;
    printf("*p = %d\n", *p);
    return 0;
}
```

#### âœ… è§£æï¼š

* `memset` å°†ç»“æ„ä½“æ‰€æœ‰ 8 å­—èŠ‚å¡«å……ä¸º `0xFF`ï¼ˆ255ï¼‰ã€‚
* `t.a = 0` è®¾ç½®åç§» 0 çš„å­—èŠ‚ä¸º 0ã€‚
* `t.b = 0` è®¾ç½®åç§» 4~~7 ä¸º 0ï¼Œå…¶é—´åç§» 1~~3 ä¸º padding å­—èŠ‚ï¼Œæ²¡æœ‰è¢«å†™å…¥ã€‚
* `&t.a + 1` æ˜¯åç§» 1 çš„åœ°å€ï¼Œå³ padding åŒºç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œå€¼ä»ä¸º `0xFF`ã€‚

#### âœ… ç»“æœè¾“å‡ºï¼š

```text
*p = 255
```

#### ğŸ’¡ æ•™å­¦ç‚¹ï¼š

* ç»“æ„ä½“å­˜åœ¨å†…å­˜å¯¹é½å’Œå¡«å……ï¼ˆpaddingï¼‰ï¼›
* è¯»å– padding åŒºåŸŸä¸ä¸€å®šæ˜¯ UBï¼ˆæœªå®šä¹‰è¡Œä¸ºï¼‰ï¼Œä½†éœ€è°¨æ…ï¼›
* `unsigned char*` æ˜¯åˆæ³•çš„ byte-wise è®¿é—®æŒ‡é’ˆã€‚

---

### ç¬¬äºŒé¢˜ï¼šæŒ‡é’ˆè¿ç®—ä¸åœ°å€åç§»

```cpp
int q2() {
    uint32_t* p = (uint32_t*)(0x81000000);
    printf("p = %p\n", p);
    printf("p + 1 = %p\n", p + 1);
    return 0;
}
```

#### âœ… è§£æï¼š

* `p` æŒ‡å‘åœ°å€ `0x81000000`
* `p + 1` ä¼šè·³è¿‡ 4 å­—èŠ‚ï¼ˆ`sizeof(uint32_t)`ï¼‰

#### âœ… è¾“å‡ºï¼š

```text
p = 0x81000000
p + 1 = 0x81000004
```

#### ğŸ’¡ æ•™å­¦ç‚¹ï¼š

* æŒ‡é’ˆè¿ç®—åŸºäºç±»å‹å¤§å°ï¼›
* è¿™ç§è£¸åœ°å€æ“ä½œåœ¨åµŒå…¥å¼å¼€å‘ä¸­å¸¸è§ï¼Œä½†åœ¨ç”¨æˆ·æ€ä¸å®‰å…¨ã€‚

---

### ç¬¬ä¸‰é¢˜ï¼šæŒ‡é’ˆä¼ å€¼ä¸æ•°ç»„ä¿®æ”¹

```cpp
void fun(int* p) {
    p++;
    *p = 80;
}

int q3() {
    int a[4] = {20, 30, 40, 50};
    int* p = &a[1];
    printf("*p = %d\n", *p);
    fun(p);
    printf("*p = %d\n", *p);
    for (int i = 0; i < 4; i++) {
        printf("a[%d] = %d\n", i, a[i]);
    }
    return 0;
}
```

#### âœ… è§£æï¼š

* `p` æŒ‡å‘ `a[1]` â†’ åˆå§‹ä¸º 30ã€‚
* `fun(p)` ä¸­ `p++` ä¸å½±å“åŸæŒ‡é’ˆï¼Œä»…ä½œç”¨äºå‰¯æœ¬ã€‚
* `*p = 80` å®é™…ä¿®æ”¹äº† `a[2]`ã€‚

#### âœ… è¾“å‡ºï¼š

```text
*p = 30
*p = 30
a[0] = 20
a[1] = 30
a[2] = 80
a[3] = 50
```

#### ğŸ’¡ æ•™å­¦ç‚¹ï¼š

* æŒ‡é’ˆä½œä¸ºå‚æ•°ä¼ å€¼ï¼Œé»˜è®¤æ˜¯å‰¯æœ¬ï¼›
* è‹¥è¦ä¿®æ”¹åŸå§‹åœ°å€ï¼Œåº”ä½¿ç”¨ `int*&` æˆ– `int**`ã€‚

---

### ç¬¬å››é¢˜ï¼šunique\_ptr æ‰€æœ‰æƒè¿ç§»

```cpp
class RealServer {
  public:
    ~RealServer() { printf("RealServer destructed\n"); }
};

struct Service {
    vector<unique_ptr<RealServer>> servers;
};

int q4() {
    Service* service1 = new Service();
    service1->servers.push_back(make_unique<RealServer>());
    Service* service2 = new Service(std::move(*service1));
    cout << service1->servers.size() << endl;
    cout << service2->servers.size() << endl;
    delete service1;
    delete service2;
    return 0;
}
```

#### âœ… è§£æï¼š

* `service1` æ‹¥æœ‰ä¸€ä¸ª `RealServer`ï¼›
* `std::move(*service1)` ä¼šè§¦å‘ `Service` çš„æˆå‘˜å˜é‡ `servers` çš„ç§»åŠ¨æ„é€ ï¼›
* æ‰€æœ‰æƒè½¬ç§»åï¼Œ`service1->servers` ä¸ºç©ºï¼Œ`service2` æ‹¥æœ‰èµ„æºã€‚

#### âœ… è¾“å‡ºï¼š

```text
0
1
RealServer destructed
```

#### ğŸ’¡ æ•™å­¦ç‚¹ï¼š

* `unique_ptr` å¼ºåˆ¶æ‰€æœ‰æƒå”¯ä¸€ï¼›
* ç§»åŠ¨æ„é€ å°†èµ„æºè½¬ç§»ï¼ŒåŸå¯¹è±¡è¢«æ¸…ç©ºï¼›
* æ³¨æ„è£¸æŒ‡é’ˆå¯¹è±¡éœ€æ‰‹åŠ¨ deleteï¼Œæ¨èç”¨ `std::unique_ptr<Service>` ç®¡ç†ã€‚

---

### ### ç¬¬äº”é¢˜ï¼š`map` é”®ç±»å‹çš„æ¯”è¾ƒè¿ç®—ç¬¦è®¾è®¡

```cpp
struct Key {
    int af;
    string id;

    Key(int af, string id) : af(af), id(id) {}
    Key(string id) : af(AF_INET), id(id) {}

    bool operator!=(const Key& other) const { return !(af == other.af && id == other.id); }
    bool operator==(const Key& other) const { return af == other.af && id == other.id; }

    // é”™è¯¯çš„å®ç°æ–¹å¼ï¼ˆæœ‰éšæ‚£ï¼‰
    bool operator<(const Key& other) const { return af < other.af && id < other.id; }
};
map<Key, string> m;
```

#### âŒ é”™è¯¯ç‚¹ï¼š

* `operator<` å†™æˆ `af < other.af && id < other.id`ï¼Œä¸ç¬¦åˆ STL å¯¹ä¸¥æ ¼å¼±åºçš„è¦æ±‚ï¼›
* å¯èƒ½å¯¼è‡´ï¼š`!(a < b) && !(b < a)` æˆç«‹ä½† `a != b`ï¼Œç ´å `map` æ­£å¸¸è¡Œä¸ºã€‚

#### âœ… æ­£ç¡®å†™æ³•ï¼š

```cpp
bool operator<(const Key& other) const {
    return af < other.af || (af == other.af && id < other.id);
}
```

#### ğŸ’¡ æ•™å­¦ç‚¹ï¼š

* `std::map` ä¾èµ– `<` å®ç°**ä¸¥æ ¼å¼±åºï¼ˆstrict weak orderingï¼‰**ï¼›
* è‡ªå®šä¹‰ç»“æ„ç”¨ä½œ map çš„ key æ—¶éœ€å°å¿ƒ operator< çš„å®šä¹‰é€»è¾‘ï¼›
* å¦‚æœç”¨äº `unordered_map`ï¼Œåˆ™åº”å®ç° `operator==` å’Œè‡ªå®šä¹‰ `std::hash<Key>`ã€‚


### 1. ç¬¬å››é¢˜ï¼Œä¸è°ƒç”¨ `std::move` ä¼šæ€ä¹ˆæ ·ï¼Ÿ`unique_ptr` çš„ä½œç”¨ï¼Ÿï¼ˆç­”ï¼šä¼šç¼–è¯‘å¤±è´¥ï¼Œ`unique_ptr` æ˜¯ä¸å¯æ‹·è´çš„ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**
åœ¨ç¬¬å››é¢˜ä¸­ï¼Œ`Service` å†…éƒ¨åŒ…å« `std::vector<std::unique_ptr<RealServer>>`ï¼Œè€Œ `unique_ptr` æ˜¯ä¸€ä¸ªç‹¬å æ‰€æœ‰æƒçš„æ™ºèƒ½æŒ‡é’ˆï¼Œä¸èƒ½æ‹·è´ï¼Œåªèƒ½ç§»åŠ¨ã€‚å¦‚æœè°ƒç”¨ `Service(*service1)` è€Œä¸æ˜¯ `std::move(*service1)`ï¼Œä¼šè§¦å‘é»˜è®¤æ‹·è´æ„é€ å‡½æ•°ï¼Œè€Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œå› ä¸º `unique_ptr` æ‹·è´æ„é€ æ˜¯è¢«ç¦ç”¨çš„ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å¦‚ä½•å®ç°æ”¯æŒæ‹·è´çš„ç‰ˆæœ¬ï¼Ÿï¼ˆæ”¹ä¸º `shared_ptr` å³å¯ï¼‰
* `shared_ptr` å’Œ `unique_ptr` åŒºåˆ«ï¼Ÿï¼ˆå‰è€…å¼•ç”¨è®¡æ•°å…±äº«æ‰€æœ‰æƒï¼Œåè€…ç‹¬å æ‰€æœ‰æƒï¼‰

---

### 2. æ„é€ ä¸ææ„é¡ºåºï¼Œè°ƒç”¨äº†å“ªäº›å‡½æ•°ï¼Ÿï¼ˆç­”ï¼šæ„é€  `RealServer`ï¼Œç§»åŠ¨æ„é€  `Service`ï¼Œææ„ `RealServer`ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* é¦–å…ˆè°ƒç”¨ `RealServer` çš„æ„é€ å‡½æ•°ï¼ˆåŒ¿åæœªæ˜¾ç¤ºï¼‰ã€‚
* ç„¶åæ‰§è¡Œ `std::move(*service1)`ï¼Œè°ƒç”¨ç¼–è¯‘å™¨ç”Ÿæˆçš„ `Service(Service&&)` ç§»åŠ¨æ„é€ å‡½æ•°ã€‚
* ç¨‹åºç»“æŸæ—¶ï¼Œå…ˆææ„ `service2`ï¼Œå…¶ä¸­ `unique_ptr<RealServer>` è¢«ææ„ï¼Œæ‰“å° "RealServer destructed"ã€‚
* æœ€åææ„ç©ºçš„ `service1`ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å¦‚æœ `RealServer` çš„æ„é€ å‡½æ•°å¸¦å‚æ•°æ€ä¹ˆåŠï¼Ÿ
* å¦‚ä½•æ˜¾ç¤ºå®šä¹‰ç§»åŠ¨æ„é€ å‡½æ•°ï¼Ÿ

---

### 3. Ping ä¸€ä¸ªåœ°å€ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿï¼ˆç­”ï¼šDNS -> åˆ›å»º socket -> æ„é€  ICMP åŒ… -> å‘é€ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

1. DNS è§£æå°†åŸŸåè½¬æ¢ä¸º IP åœ°å€ã€‚
2. åˆ›å»ºåŸå§‹ socketï¼ˆraw socketï¼‰ã€‚
3. æ„é€  ICMP Echo Request æŠ¥æ–‡ã€‚
4. ä½¿ç”¨ socket å‘é€æŠ¥æ–‡åˆ°ç›®æ ‡åœ°å€ã€‚
5. æ¥æ”¶ ICMP Echo Replyã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* ping ä¸ºä»€ä¹ˆéœ€è¦ root æƒé™ï¼Ÿï¼ˆå› ä¸º raw socketï¼‰
* ping é»˜è®¤ä½¿ç”¨å“ªä¸ªåè®®ï¼Ÿï¼ˆICMPï¼‰

---

### 4. ICMP åŒ…éœ€è¦å‘é€å“ªäº›å†…å®¹ï¼Ÿï¼ˆç­”ï¼štypeã€codeã€æ ¡éªŒå’Œç­‰ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä¸€ä¸ªæ ‡å‡† ICMP Echo Request æŠ¥æ–‡ç»“æ„åŒ…æ‹¬ï¼š

* Typeï¼ˆ8 è¡¨ç¤º Echo Requestï¼‰
* Codeï¼ˆ0ï¼‰
* Checksumï¼ˆæ ¡éªŒå’Œï¼‰
* Identifier + Sequence Number
* Payload æ•°æ®

**æ‰©å±•é—®é¢˜ï¼š**

* æ ¡éªŒå’Œå¦‚ä½•è®¡ç®—ï¼Ÿï¼ˆå¯¹æ•´ä¸ªåŒ…æŒ‰ 16 ä½ä¸ºå•ä½æ±‚åç å’Œï¼‰
* ICMP æ˜¯å¦ä¿è¯å¯é æ€§ï¼Ÿï¼ˆä¸ä¿è¯ï¼‰

---

### 5. ICMP åŒ…æ˜¯æ€ä¹ˆåˆ°ç›®æ ‡åœ°å€çš„ï¼Ÿï¼ˆç­”ï¼šé€šè¿‡ IP è·¯ç”±è½¬å‘ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* åŒ…ç”±æœ¬åœ°è·¯ç”±è¡¨å†³å®šä¸‹ä¸€è·³ï¼›
* å‘é€åˆ°é»˜è®¤ç½‘å…³ï¼ˆå¦‚ç›®æ ‡ä¸åœ¨åŒä¸€å­ç½‘ï¼‰ï¼›
* è·¯ç”±å™¨é€è·³è½¬å‘ï¼Œç›´åˆ°åˆ°è¾¾ç›®æ ‡åœ°å€ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* Traceroute çš„åŸç†ï¼Ÿï¼ˆé€æ­¥å¢åŠ  TTLï¼Œçœ‹æ¯è·³è¿”å›çš„ ICMP Time Exceededï¼‰

---

### 6. å¦‚ä½•åˆ¤æ–­ IP åœ°å€æ˜¯å¦åœ¨é»‘åå•ï¼Ÿï¼ˆç­”ï¼šå¯ç”¨ setã€ä½å›¾ã€Trieï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* å°é‡ IP å¯ç”¨ `std::set` æˆ– `unordered_set`ã€‚
* å¤§é‡è¿ç»­ IP å¯ç”¨ä½å›¾ï¼ˆbitmapï¼‰æˆ–æ®µæ ‘ã€‚
* å¦‚æœæ˜¯ CIDR æ®µï¼Œå¯ç”¨ Trie æˆ–å‰ç¼€æ ‘ç»“æ„ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* æ€ä¹ˆå­˜å‚¨ `10.0.0.0/8` ï¼Ÿï¼ˆå‰ç¼€æ ‘ï¼‰
* ä½å›¾æ˜¯å¦æ”¯æŒ IPv6ï¼Ÿï¼ˆç©ºé—´å¼€é”€è¿‡å¤§ï¼‰

---

### 7. å¤šçº¿ç¨‹å¸¸ç”¨çš„é”æœ‰å“ªäº›ï¼Ÿï¼ˆç­”ï¼šäº’æ–¥é”ã€è¯»å†™é”ã€é€’å½’é”ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* `mutex`ï¼šæœ€å¸¸ç”¨çš„äº’æ–¥é”ã€‚
* `recursive_mutex`ï¼šæ”¯æŒåŒä¸€çº¿ç¨‹é‡å¤åŠ é”ã€‚
* `shared_mutex`ï¼šæ”¯æŒè¯»å†™é”ï¼ˆC++17ï¼‰ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* è‡ªæ—‹é”å’Œäº’æ–¥é”çš„åŒºåˆ«ï¼Ÿï¼ˆå¿™ç­‰ vs é˜»å¡ï¼‰
* æ¡ä»¶å˜é‡æ˜¯é”å—ï¼Ÿï¼ˆä¸æ˜¯ï¼Œç”¨äºçº¿ç¨‹åŒæ­¥ï¼‰

---

### 8. åç¨‹å†™ channelï¼Œéœ€è¦åŠ é”å—ï¼Ÿï¼ˆç­”ï¼šä¸éœ€è¦ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**
åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­çš„åç¨‹å…±äº« channel æ—¶ï¼Œæ— éœ€åŠ é”ã€‚
åŸå› ï¼šåç¨‹åœ¨åŒä¸€ä¸ªçº¿ç¨‹è°ƒåº¦ï¼Œä¸å­˜åœ¨å¹¶å‘è®¿é—®é—®é¢˜ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å¦‚æœå¤šçº¿ç¨‹è®¿é—®åŒä¸€ä¸ª channel å‘¢ï¼Ÿï¼ˆéœ€è¦åŠ é”æˆ–ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„ channel å®ç°ï¼‰

---

### 9. ç½‘å…³å¦‚ä½•æ”¯æŒé«˜å¹¶å‘ï¼Ÿï¼ˆç­”ï¼šepoll/iouring + çº¿ç¨‹æ± ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* ä½¿ç”¨ epollã€IOCPã€io\_uring ç­‰é«˜æ•ˆ IO å¤šè·¯å¤ç”¨ï¼›
* æ­é…çº¿ç¨‹æ± å¤„ç†è¯·æ±‚ï¼›
* ä¼˜åŒ–å†…å­˜åˆ†é…ï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* ä¸ºä»€ä¹ˆä¸ç”¨ä¸€ä¸ªçº¿ç¨‹ä¸€ä¸ªè¿æ¥ï¼Ÿï¼ˆä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€å¤§ï¼‰
* ä»€ä¹ˆæ˜¯ io\_uringï¼Ÿï¼ˆLinux æ–°ä¸€ä»£å¼‚æ­¥ IO æ¡†æ¶ï¼‰

---

### 10. select/poll èƒ½å®ç°é«˜å¹¶å‘å—ï¼Ÿï¼ˆç­”ï¼šå¯ä»¥ï¼Œä½†æ•ˆç‡ä½äº epollï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* select/poll éƒ½æ˜¯ IO å¤šè·¯å¤ç”¨æœºåˆ¶ï¼›
* æ”¯æŒé«˜å¹¶å‘ï¼Œä½†æ•ˆç‡ä½ï¼š

  * select æœ‰æœ€å¤§ fd é™åˆ¶ï¼›
  * poll æ¯æ¬¡éƒ½è¦éå†æ‰€æœ‰ fdï¼›
* epoll æ›´ä¼˜ï¼ŒåŸºäºäº‹ä»¶é©±åŠ¨ï¼ŒO(1) å¤æ‚åº¦ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* select æœ€å¤šæ”¯æŒå¤šå°‘ä¸ª fdï¼Ÿï¼ˆé€šå¸¸æ˜¯ 1024ï¼‰

---

### 11. çº¿ç¨‹æ± å®ç°éœ€è¦æ³¨æ„ä»€ä¹ˆï¼Ÿï¼ˆç­”ï¼škeep alive æ—¶é—´ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* ç®¡ç†ä»»åŠ¡é˜Ÿåˆ—ï¼Œé¿å…é˜»å¡ï¼›
* åˆç†è®¾ç½®çº¿ç¨‹æ•°ä¸ keep alive æ—¶é—´ï¼›
* é¿å…çº¿ç¨‹æ³„éœ²æˆ–èµ„æºç«äº‰ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å·¥ä½œçªƒå–æœºåˆ¶ï¼Ÿï¼ˆwork stealingï¼‰
* å¦‚ä½•ä¼˜é›…é€€å‡ºçº¿ç¨‹æ± ï¼Ÿï¼ˆé€šçŸ¥ + joinï¼‰

---

### 12. å¤šæ ¸ç³»ç»Ÿä¼˜åŒ–æ€ä¹ˆåšï¼Ÿï¼ˆç­”ï¼šè´Ÿè½½å‡è¡¡ + å¤šè·¯å¤ç”¨ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* ä½¿ç”¨å¤šçº¿ç¨‹/å¤šè¿›ç¨‹å‡åŒ€åˆ©ç”¨ CPUï¼›
* å°†ä¸åŒè¿æ¥æˆ–è®¡ç®—ç»‘å®šåˆ°ä¸åŒæ ¸å¿ƒï¼ˆCPU äº²å’Œæ€§ï¼‰ï¼›
* ä½¿ç”¨ epoll/kqueue å®ç° IO å¤šè·¯å¤ç”¨ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å¦‚ä½•é¿å… false sharingï¼Ÿï¼ˆç»“æ„ä½“æˆå‘˜å¡«å……å¯¹é½ï¼‰

---

### 13. å¤šçº¿ç¨‹é™¤äº†åŠ é”è¿˜èƒ½ç”¨ä»€ä¹ˆï¼Ÿï¼ˆç­”ï¼šåŸå­æ“ä½œï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* ä½¿ç”¨ `std::atomic` å®ç°æ— é”ç¼–ç¨‹ï¼›
* ä½¿ç”¨ CASï¼ˆCompare-And-Swapï¼‰å¤„ç†å¹¶å‘å†²çªï¼›
* ä½¿ç”¨ lock-free/ wait-free æ•°æ®ç»“æ„æå‡æ€§èƒ½ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* åŸå­æ“ä½œå’Œäº’æ–¥é”çš„åŒºåˆ«ï¼Ÿï¼ˆé”å¯èƒ½é˜»å¡ï¼‰
* `std::atomic<int>++` æ˜¯åŸå­çš„å—ï¼Ÿï¼ˆæ˜¯ï¼‰

---

### 14. `i++` æ˜¯åŸå­æ“ä½œå—ï¼Ÿï¼ˆç­”ï¼šä¸æ˜¯ï¼ŒåŒ…å«è¯»-æ”¹-å†™ä¸‰æ­¥ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**
`i++` å¹¶ä¸æ˜¯åŸå­æ“ä½œï¼Œå…¶èƒŒåæ˜¯ï¼š

1. ä»å†…å­˜è¯» i
2. åœ¨å¯„å­˜å™¨åŠ ä¸€
3. å†™å›å†…å­˜

è¿™ä¸‰ä¸ªæ­¥éª¤ä¸æ˜¯åŸå­å®Œæˆï¼Œå­˜åœ¨çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚

**æ‰©å±•é—®é¢˜ï¼š**

* å¦‚ä½•è®© `i++` æˆä¸ºåŸå­ï¼Ÿï¼ˆä½¿ç”¨ `std::atomic<int>`ï¼‰

---

### 15. åœ¨ 64 ä½æœºå™¨ä¸Šï¼Œç»™ 32 ä½å˜é‡èµ‹å€¼æ˜¯åŸå­çš„å—ï¼Ÿï¼ˆç­”ï¼šä¸æ˜¯ï¼Œæˆ–è€…å–å†³äºæ¶æ„ï¼‰

**æ ‡å‡†ç­”æ¡ˆï¼š**

* å¯¹é½è‰¯å¥½ã€ç¡¬ä»¶æ”¯æŒä¸‹ï¼Œæœ‰å¯èƒ½æ˜¯åŸå­ï¼›
* ä½†ä¸èƒ½ä¾èµ–å®ç°ï¼Œè·¨å¹³å°è¡Œä¸ºä¸ä¸€è‡´ï¼›
* ä¸ºä¿è¯åŸå­æ€§ï¼Œä½¿ç”¨ `std::atomic<uint32_t>`

**æ‰©å±•é—®é¢˜ï¼š**

* x86 ä¸Š 32 ä½å¯¹é½å˜é‡é€šå¸¸æ˜¯åŸå­çš„ï¼ŒARM å‘¢ï¼Ÿï¼ˆå–å†³äºæ¶æ„ï¼‰
* å¯¹æ¯” `volatile` å’Œ `atomic`ï¼Ÿï¼ˆå‰è€…ä¸èƒ½ä¿è¯åŒæ­¥ï¼‰
